# Moderne Softwareentwicklung


## Einsendeaufgabe: DSL

Denis Renning (BHT 914556)

### Aufgabenstellung
1. Bauen sie eine sinnvolle Java DSL im Stile des Expression Builders / Fluent Interfaces, zu Ihrer Lieblingsdomain. Natürlich können sie das auch in jeder anderen Programmiersprache tun.

2. Spielen sie mit Xtext, ANTLR, (MPS) oder anderen Werkzeugen herum und erstellen sie Ihre eigene Mikro-Sprache.


### Und schon schon schon wieder NEB27

#### Java Fluent Interfaces

Bsp.:
```java
Fahrt.builder().uhrzeit("16:00").start("Karow").ziel("Wandlitz").build(); //hier mit BuilderPattern
```

In Ihrem Skript 12.4 heisst es

> Java scheint keine allzu gute Sprache für DSLs zu sein. Der Code ist umfangreich und enthält zu viel 'Boilerplate' Code (langweilige / umständliche Codebausteine). Moderne dynamische Sprachen könnten dafür besser geeignet sein.

und 

> Es bleibt die Frage ob das auch in Java einfacher geht

Für das Beispiel NEB27 hab ich dafür mal auf das [Lombok](https://projectlombok.org/)-Projekt zurück gegriffen. Netterweise erspart uns dass nämlich eine Menge der "langweiligen" und "umständlichen" Codebausteine und die Implementierung der Bean mit Builder-Pattern verringert sich auf nicht mal 10 Zeilen Code:

```java
package com.devtty.antlr;

import lombok.Builder;

@Builder 
@Getter 
@Setter
public class Fahrt {
    
    private String start;
    private String ziel;
    private String uhrzeit;
}
```

Die Lombok-Bibliothek sorgt dann beim Zusammenbauen für den restlich notwendigen Code im Hintergrund. Ausschlaggebend sind hier die drei Annotationen vor der Klassendeklaration. Mit Anwendung des entsprechenden Maven-Plugins kann der Zwischenschritt bzw. der aus der Klasse generierte Quellcode auch sichtbar gemacht werden. Entfernt man die ```SuppressWarnings``` sieht das Ganze auch dem Beispiel aus dem Vorlesungsskript (12.4) sehr ähnlich.

<details>
  <summary>Hier klicken (für generierte Klasse)</summary>

```java
// Generated by delombok at Fri Jan 07 14:29:41 CET 2022
package com.devtty.antlr;

public class Fahrt {
    private String start;
    private String ziel;
    private String uhrzeit;

    @java.lang.SuppressWarnings("all")
    Fahrt(final String start, final String ziel, final String uhrzeit) {
        this.start = start;
        this.ziel = ziel;
        this.uhrzeit = uhrzeit;
    }


    @java.lang.SuppressWarnings("all")
    public static class FahrtBuilder {
        @java.lang.SuppressWarnings("all")
        private String start;
        @java.lang.SuppressWarnings("all")
        private String ziel;
        @java.lang.SuppressWarnings("all")
        private String uhrzeit;

        @java.lang.SuppressWarnings("all")
        FahrtBuilder() {
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public Fahrt.FahrtBuilder start(final String start) {
            this.start = start;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public Fahrt.FahrtBuilder ziel(final String ziel) {
            this.ziel = ziel;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public Fahrt.FahrtBuilder uhrzeit(final String uhrzeit) {
            this.uhrzeit = uhrzeit;
            return this;
        }

        @java.lang.SuppressWarnings("all")
        public Fahrt build() {
            return new Fahrt(this.start, this.ziel, this.uhrzeit);
        }

        @java.lang.Override
        @java.lang.SuppressWarnings("all")
        public java.lang.String toString() {
            return "Fahrt.FahrtBuilder(start=" + this.start + ", ziel=" + this.ziel + ", uhrzeit=" + this.uhrzeit + ")";
        }
    }

    @java.lang.SuppressWarnings("all")
    public static Fahrt.FahrtBuilder builder() {
        return new Fahrt.FahrtBuilder();
    }

    @java.lang.SuppressWarnings("all")
    public String getStart() {
        return this.start;
    }

    @java.lang.SuppressWarnings("all")
    public String getZiel() {
        return this.ziel;
    }

    @java.lang.SuppressWarnings("all")
    public String getUhrzeit() {
        return this.uhrzeit;
    }

    @java.lang.SuppressWarnings("all")
    public void setStart(final String start) {
        this.start = start;
    }

    @java.lang.SuppressWarnings("all")
    public void setZiel(final String ziel) {
        this.ziel = ziel;
    }

    @java.lang.SuppressWarnings("all")
    public void setUhrzeit(final String uhrzeit) {
        this.uhrzeit = uhrzeit;
    }
}

```
</details

Alternativ können mittels '''@Accessors''' auch nur die Methoden angefasst werden und das Endergebnis entspräche ihrem vereinfachten Fluent-Interface aus Abschnitt 12.5.
Weiterhin interessant ist (das noch experimentelle) '''@SuperBuilder''', da hier Felder von Superclass mit berücḱsichtigt werden können.

Letztendlich geht es aber auch mit Java recht einfach :smile:

#### ANTLR 4 and Maven Tutorial

thanks to [Alex Collins](https://alexecollins.com/antlr4-and-maven-tutorial/) (@alexec) :smile:

Für 

src/main/resources

```
"NEB siebnunzwanzich"
16:52 Uhr von "Gesundbrunnen" nach "Schoenerlinde"
17:04 Uhr von "Schoenerlinde" nach "Schoenwalde"
17:07 Uhr von "Schoenwalde" nach "Basdorf"
17:10 Uhr von "Basdorf" nach "Wandlitz"
17:14 Uhr von "Wandlitz" nach "Wandlitzsee"

```

src/main/antlr4/

Line.g4

```
grammar Line;

line:
  name=Str NL
  (fahrt NL)+
  EOF;
  
fahrt: uhrzeit WS 'Uhr' WS 'von' WS startbahnhof=Str WS 'nach' WS zielbahnhof=Str;
uhrzeit: stunde=Int ':' minute=Int;

Str: '"' ('A'..'Z' | 'a'..'z' | ' ')+ '"' ;
Int: ('0'..'9')+;

WS: (' ' | '\t')+;
NL: '\r'? '\n';
```

